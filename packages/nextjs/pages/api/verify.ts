import { ZKEdDSAEventTicketPCDPackage } from "@pcd/zk-eddsa-event-ticket-pcd";
import { NextApiRequest, NextApiResponse } from "next";
import { createWalletClient, http, isAddress, parseEther } from "viem";
import { hardhat } from "viem/chains";
import { isZupassPublicKey } from "zuauth";

const localWalletClient = createWalletClient({
  chain: hardhat,
  transport: http(),
});

const accounts = await localWalletClient.getAddresses();
// const validEventIds = ["b03bca82-2d63-11ee-9929-0e084c48e15f"]; //get the event id from https://api.zupass.org/issue/known-ticket-types

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const pcd = await ZKEdDSAEventTicketPCDPackage.deserialize(req.body.pcd);
  const address = req.body.address;

  if (!isAddress(address)) {
    res.status(401).send("Invalid address");
    return;
  }

  if (!(await ZKEdDSAEventTicketPCDPackage.verify(pcd))) {
    console.error(`[ERROR] ZK ticket PCD is not valid`);

    res.status(401).send("ZK ticket PCD is not valid");
    return;
  }
  if (!isZupassPublicKey(pcd.claim.signer)) {
    console.error(`[ERROR] PCD is not signed by Zupass`);

    res.status(401).send("PCD is not signed by Zupass");
    return;
  }

  // TODO: Use real nonce generated by the server
  if (pcd.claim.watermark.toString() !== "1") {
    console.error(`[ERROR] PCD watermark doesn't match`);

    res.status(401).send("PCD watermark doesn't match");
    return;
  }

  //TODO: think about nullifiers
  // TODO: Check for support event ids

  await localWalletClient.sendTransaction({ to: req.body.address, value: parseEther("1"), account: accounts[0] });

  res.status(200).json({ message: "Sucess" });
}
